function [finalListGlitches, nShapes, glDiff] = glitchGenerator(zpk, fsGlitch, fs)
% fsGlitch is an arbitrary frequency from which the glitches are built; the
% higher it is, the more precise the resolution. fs is the studied 
% sampling frequency, and the zpk are the poles and zeros from the
% metadata.

pTransfer = zpk(end).poles;
zTransfer = zpk(end).zeros;

dt = 1/fsGlitch;
NS = 32*1024;


%% build Green response from Pole and Zero ( remove the two first null zero)
green(1:NS)=0.;
green(NS/2)=1.;	% impulse function
time=(0:NS-1)*dt;
tfGreen=fft(green);
NF=floor(NS/2+1);
omega(1:NF)=(0:NF-1)/(NS*dt)*(2*1i*pi);

% remove the two first zeros and keep the other ones
for zero=3:length(zTransfer)
	tfGreen(1:NF)=tfGreen(1:NF).*(omega(1:NF)-zTransfer(zero));
end

% take all poles
for pole=1:length(pTransfer)
	tfGreen(1:NF)=tfGreen(1:NF)./(omega(1:NF)-pTransfer(pole));
end

% get the time function of the Green response
initialGlitch=ifft(tfGreen,'symmetric')';


%% create nShapes glitches from the initial one
nShapes = fsGlitch/fs;
listGlitches = zeros(length(initialGlitch), nShapes);
for j=1:nShapes
	listGlitches(:,j)=[initialGlitch(j:end);(1:j-1)'*0];
end


%% under-sample the glitch to signal sampling frequency
% load the filters
keyset = [4 2 5];
keyset = sort(keyset,'descend');
PFO = containers.Map('KeyType','int32', 'ValueType', 'any');
gain = containers.Map('KeyType','int32', 'ValueType', 'any');
N = containers.Map('KeyType','int32', 'ValueType', 'any');
for i=keyset
	PFO(i) = load(['PFO_div' int2str(i) '.txt']);
	gain(i) = sum(PFO(i));
	N(i) = length(PFO(i));
end

% remove the factors of fs in fsGlitch
factorFsGlitch = factor(fsGlitch);
factorFs = factor(fs);
for elt=factorFs
	factorIndex = find(factorFsGlitch==elt,1);
	if ~isempty(factorIndex)
		factorFsGlitch = [factorFsGlitch(1:factorIndex-1) factorFsGlitch(factorIndex+1:end)];
	else
		error("The glitch at freq " + fs + " can not be generated by the zpk at freq " + fsGlitch0)
	end
end

% under-sample the glitches
factorFsGlitch0=factorFsGlitch;
newListGlitches = zeros(length(listGlitches(:,1)), nShapes);
lenGlitch=0;
for j=1:nShapes
	factorFsGlitch=factorFsGlitch0;
	glitch = listGlitches(:,j);
	for i=keyset
		factorIndex = find(factorFsGlitch==i);
		for index = factorIndex
			glitch = resampleGlitch(glitch, i, PFO(i), gain(i));
			factorFsGlitch = [factorFsGlitch(1:index-1) 1 factorFsGlitch(index+1:end)];
		end
	end
	fsGlitch = prod(factorFsGlitch);
	if fsGlitch ~= 1
		error("The glitch at freq " + fs + " can not be generated by the zpk at freq " + fsGlitch0)
	end
	newListGlitches(1:length(glitch),j)=glitch;
	lenGlitch = max(length(glitch),lenGlitch);
end

newListGlitches = newListGlitches(1:lenGlitch,:);
for j = 1:nShapes
    newListGlitches(:,j) = newListGlitches(:,j)./max(newListGlitches(:,j));
end
glitch = newListGlitches(:,1);


%% trim the glitch to remove the null values
maxGlitch = max(abs(glitch));
firstHalfPoint = lenGlitch+1;
secondHalfPoint = 0;
for posInGlitch=1:lenGlitch
	if firstHalfPoint>lenGlitch && abs(glitch(posInGlitch))>maxGlitch/2
		firstHalfPoint = posInGlitch;
	end
	if firstHalfPoint<=lenGlitch && secondHalfPoint <1 && abs(glitch(posInGlitch))<maxGlitch/2
		secondHalfPoint = posInGlitch;
	end
end
refSizeGlitch = secondHalfPoint-firstHalfPoint;

beginningPoint = lenGlitch+1;
endPoint = 0;
for posInGlitch=1:lenGlitch
	if beginningPoint>lenGlitch && abs(glitch(posInGlitch))>0.01*maxGlitch
		beginningPoint = posInGlitch;
		break
	end
end
while posInGlitch <= lenGlitch
	if abs(glitch(posInGlitch))>0.01*maxGlitch
		endPoint = posInGlitch;
	end
	posInGlitch = posInGlitch+1;
end

window = max(1,beginningPoint-refSizeGlitch):min(lenGlitch,endPoint+2*refSizeGlitch);
finalListGlitches=zeros(length(window),nShapes);
for j=1:nShapes
	finalListGlitches(:,j) = newListGlitches(window,j);
end


%% find glDiff
maxGrad = max(abs(gradient(finalListGlitches(:,1))));
glDiff = find(abs(gradient(finalListGlitches(:,1)))./maxGrad >= 0.1,1);

end